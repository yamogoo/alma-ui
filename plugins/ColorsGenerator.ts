import fs from "node:fs";
import Color from "color";

interface ColorsGeneratorOptions {
  source: string;
  outDir: string;
  step?: number;
  comment?: string;
  writeMarkdownFiles?: boolean;
}

interface MainColor {
  id: string;
  name: string;
  value: string;
  step: number;
  prefix: string;
  separator: string;
}

interface DerivativeColor {
  id: string;
  name: string;
  fullName: string;
  value: string;
  increment: number;
  lightness: number;
  isLight: boolean;
}

type DerivativeColors = DerivativeColor[];

// Generates a set of lighter colors
export const generateDerivativeColors = (
  color: MainColor
): DerivativeColors => {
  const tempColors: DerivativeColors = [];
  const {
    id,
    name: rootName,
    value: rootValue,
    step,
    prefix,
    separator,
  } = color;

  const colorLightnessFactor = 100 / (step + 2);

  for (let i = 0; i <= step; i++) {
    const increment = Math.round(1000 - (1000 / step) * i);
    const fullName = `${prefix}${rootName}${separator}${increment}`;

    const colorInstance = Color(rootValue).lightness(
      (i + 1) * colorLightnessFactor
    );

    const value = colorInstance.hex();
    const lightness = colorInstance.lightness();
    const isLight = colorInstance.isLight();

    const derivative: DerivativeColor = {
      id: `${id}${i}`,
      name: prefix,
      fullName,
      value,
      increment,
      lightness,
      isLight,
    };

    tempColors.push(derivative);
  }

  return tempColors.sort((a, b) => a.increment - b.increment);
};

export const generateColorsFromFile = (opts: ColorsGeneratorOptions): void => {
  const {
    source,
    outDir,
    step = 20,
    comment = `# ${outDir} Generated by ColorsGenerator. !! DO NOT MODIFY THIS FILE !!\n`,
    writeMarkdownFiles = false,
  } = opts;

  if (!/\.json$/.test(source)) {
    throw new Error("Invalid source file: must be a .json file.");
  }

  const raw = fs.readFileSync(source, "utf-8");
  const parsed = JSON.parse(raw);

  const resultMap: Record<string, string> = {};

  const traverse = (
    obj: Record<string, any>,
    pathSegments: string[] = []
  ): void => {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = [...pathSegments, key];
      if (typeof value === "string") {
        const colorDef: MainColor = {
          id: currentPath.join("-"),
          name: key,
          value,
          step,
          prefix: currentPath.slice(0, -1).join("-"),
          separator: "-",
        };

        const generated = generateDerivativeColors(colorDef);
        for (const c of generated) {
          resultMap[c.fullName] = c.value;
        }
      } else if (typeof value === "object" && value !== null) {
        traverse(value, currentPath);
      }
    }
  };

  traverse(parsed);

  const outputPath = outDir.endsWith(".json") ? outDir : `${outDir}.json`;
  const markdownPath = outputPath.replace(/\.json$/, ".md");

  try {
    fs.writeFileSync(outputPath, JSON.stringify(resultMap, null, 2), "utf-8");
    fs.writeFileSync(markdownPath, comment, "utf-8");

    if (!writeMarkdownFiles) return;
    console.log(`✅ Colors written to: ${outputPath}`);
  } catch (err) {
    console.error("❌ Failed to write output:", err);
  }
};
